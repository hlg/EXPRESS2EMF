#using ExpressEMF.*
#using AttrCondDefLibrary.*

#abstract #rule ExplicitAttributeToStructuralFeature #with ExpressEMF

#source { 
	e:EntityDecl
	++n: AttributeDecl
}

#target {
	c:EClass  { 
		++ -eStructuralFeatures->s
	}
	++ s:EStructuralFeature {
		++ -eType->cf
		++ -eAnnotations->ea
	}
	++ ea:EAnnotation {
		++ -details-> det
    }
	++ det:EStringToStringMapEntry
	
	cf:EClassifier
}

#correspondence {
	e2c: EntityToClass{
		#src->e
		#trg->c
	}
	++ n2s: AttributeDeclToStructuralFeature{
		#src->n
		#trg->s
	}
	
}
#attributeConditions {
	eq_string(n.name, s.name)
	eq_string("Express_emoflon", ea.source)
	eq_string("position", det.key)
	stringToInt(det.value, n.position)
}

#abstract #rule FirstExplicitAttributeToStructuralFeature #extends ExplicitAttributeToStructuralFeature #with ExpressEMF
#source {
	e:EntityDecl {
		++ -attrs-> a
	}
	++a: ExplicitAttr{
		++ -attrs->n
	}
}

#abstract #rule SubsequentExplicitAttributeToStructuralFeature #extends ExplicitAttributeToStructuralFeature #with ExpressEMF
#source {
	e:EntityDecl {
		-attrs-> a
	}
	a: ExplicitAttr{
		++ -attrs->n
	}
}

#abstract #rule ExplicitAttributeToReference #with ExpressEMF
#source{
	d:NamedTypeDecl // TODO all NamedTypeDecl	
}
#target {
	++ s:EReference
	cf:EClass	
}
#correspondence {
	t2cf:EntityToClass{
		#src->d
		#trg->cf
	}
}


#abstract #rule ExplicitAttributeToAttribute #with ExpressEMF

#source {
	t:SimpleTypes 
}
#target {
	++ s:EAttribute
	cf:EDataType
}
#correspondence {
	t2cf:SimpleTypeToDataType {
		#src->t
		#trg->cf
	}
}

#rule FirstExplicitAttributeToReference #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	++ a: ExplicitAttr{
		++ -type->t
	}
	++ t:NamedTypes {
		++ -decl->d
	} 
	d:NamedTypeDecl // TODO all NamedTypeDecl
}


#abstract #rule FirstExplicitAggregateAttributeToReference #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	++a: ExplicitAttr{
		++ -type->g
	}
	++ g: GeneralAggregationTypes {
		++ -type->t
	}
	++ t:NamedTypes {
		++ -decl->d
	} 
	d:NamedTypeDecl // TODO all NamedTypeDecl
}
#target{
	++s:EReference
}
#attributeConditions{
	eq_int(-1, s.upperBound)
}

#rule FirstExpliciteListAttributeToReference #extends FirstExplicitAggregateAttributeToReference #with ExpressEMF
#source {
	++ g: GeneralListType
}
#rule FirstExpliciteSetAttributeToReference #extends FirstExplicitAggregateAttributeToReference #with ExpressEMF
#source {
	++ g: GeneralSetType
}

#rule FirstExplicitAttributeToAttribute #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToAttribute #with ExpressEMF
#source {
	++ a: ExplicitAttr{
		++ -type->t
	}
	t:SimpleTypes // TODO maybe not necessary, target side distinction enough because existing t/cf correspondence
}

#rule SubsequentExplicitAttributeToReference #extends SubsequentExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	a: ExplicitAttr{
		-type->t
	}
	t:NamedTypes {
		-decl->d
	} 
	d:NamedTypeDecl // TODO all NamedTypeDecl
}

#rule SubsequentExplicitAttributeToAttribute #extends SubsequentExplicitAttributeToStructuralFeature, ExplicitAttributeToAttribute #with ExpressEMF
#source {
	a: ExplicitAttr{
		-type->t
	}
	t:SimpleTypes // TODO check, maybe not necessary, target side distinction enough because existing t/cf correspondence
}
/*
*/