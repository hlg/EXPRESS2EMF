#using ExpressEMF.*
#using AttrCondDefLibrary.*

#abstract #rule ExplicitAttributeToStructuralFeature #with ExpressEMF

#source { 
	e:EntityDecl
	++n: AttributeDecl 
}

#target {
	c:EClass  { 
		++ -eStructuralFeatures->s
	}
	++ s:EStructuralFeature {
		++ -eType->cf
	}
	cf:EClassifier
}

#correspondence {
	e2c: EntityToClass{
		#src->e
		#trg->c
	}
	++ n2s: AttributeDeclToStructuralFeature{
		#src->n
		#trg->s
	}
	
}
#attributeConditions {
	eq_string(n.name, s.name)
}

#abstract #rule FirstExplicitAttributeToStructuralFeature #extends ExplicitAttributeToStructuralFeature #with ExpressEMF
#source {
	e:EntityDecl {
		++ -attrs-> a
	}
	++a: ExplicitAttr{
		++ -attrs->n
	}
}

#abstract #rule SubsequentExplicitAttributeToStructuralFeature #extends ExplicitAttributeToStructuralFeature #with ExpressEMF
#source {
	e:EntityDecl {
		-attrs-> a
	}
	a: ExplicitAttr{
		++ -attrs->n
	}
}

#abstract #rule ExplicitAttributeToReference #with ExpressEMF
#source{
	d:EntityDecl // TODO all NamedTypeDecl	
}
#target {
	++ s:EReference
	cf:EClass	
}
#correspondence {
	t2cf:EntityToClass{
		#src->d
		#trg->cf
	}
}


#abstract #rule ExplicitAttributeToAttribute #with ExpressEMF

#source {
	t:SimpleTypes 
}
#target {
	++ s:EAttribute
	cf:EDataType
}
#correspondence {
	t2cf:SimpleTypeToDataType {
		#src->t
		#trg->cf
	}
}
#attributeConditions {
	
	
}

#rule FirstExplicitAttributeToReference #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	++ a: ExplicitAttr{
		++ -type->t
	}
	++ t:NamedTypes {
		++ -decl->d
	} 
	d:EntityDecl // TODO all NamedTypeDecl
}


#rule FirstExplicitAggregateAttributeToReference #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	++a: ExplicitAttr{
		++ -type->g
	}
	++ g: GeneralSetType {
		++ -type->t
	}
	++ t:NamedTypes {
		++ -decl->d
	} 
	d:EntityDecl // TODO all NamedTypeDecl
}
#target{
	++s:EReference
}
#attributeConditions{
	eq_int(-1, s.upperBound)
}

#rule FirstExplicitAttributeToAttribute #extends FirstExplicitAttributeToStructuralFeature, ExplicitAttributeToAttribute #with ExpressEMF
#source {
	++ a: ExplicitAttr{
		++ -type->t
	}
	t:SimpleTypes // TODO maybe not necessary, target side distinction enough because existing t/cf correspondence
}

/*
#rule SubsequentExplicitAttributeToReference #extends SubsequentExplicitAttributeToStructuralFeature, ExplicitAttributeToReference #with ExpressEMF
#source {
	a: ExplicitAttr{
		-type->t
	}
	t:NamedTypes {
		-decl->d
	} 
	d:EntityDecl // TODO all NamedTypeDecl
}

#rule SubsequentExplicitAttributeToAttribute #extends SubsequentExplicitAttributeToStructuralFeature, ExplicitAttributeToAttribute #with ExpressEMF
#source {
	a: ExplicitAttr{
		-type->t
	}
	t:SimpleTypes // TODO check, maybe not necessary, target side distinction enough because existing t/cf correspondence
}
*/